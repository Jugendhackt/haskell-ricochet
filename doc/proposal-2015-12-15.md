Proposal proposed the 15th December of 2015
===========================================
We decided it would make sense to split the API into multiple levels, each
getting more and more abstract, but targeting progressively more specific parts
of the ricochet spec.

### First Level: Version Negotiation
The lowest level of the API will be the ricochet version negotiation. This is
the only part of the spec that definetly won't change in future versions and can
therefore doesn't target any specific version of the ricochet spec.

The most abstract part of the API on this level will probably look something
like this:
```haskell
runRicochet :: RSAKeyPair -> (Word8 -> IO ()) -> IO ()
```

### Second Level: Packet Parsing
The second level will implement the parsing of generic ricochet packets from
`ByteString`s. This was specified in protocol version 1 and is therefore not
version agnostic, but also seems like something that will stay the same in
future versions.

Note that the concept of channels already exists at this level but there are no
usefull abstractions for it.

### Third Level: Ricochet Primitives
This level will implement the primitives introduced by ricochet version 1,
namely the authentication process for `im.ricochet.auth.hidden-service` and the
protobuf parsing of the specified structures.

### Fourth Level: High Level API
This level will be what most users of this library will interact with. It's an
high level interface to the ricochet protocol. The user will get a `Channel`
carrying a sum type for each connected peer. This will represent the
`Control channel` from the ricochet spec and give them full control over the
interaction with their contacts.

This may also be used as the base of a even higher level callback based API.

> TODO: Further discuss how OpenChannel requests should be handled
